# java SE Lesson 15

```
序列化

将对象转化为字节流保存起来, 并在以后还原这个对象, 这种机制叫做对象序列化
将内存上的person对象保存到文件上,下次虚拟机启动的时候再将它从文件读取出来
被引用的对象都会被序列化

将一个对象保存到永久的存储设备上叫持久化

一个对象要想能够实现序列化, 必须实现 Serializable 接口或 Externalizable接口
```

```
反序列化
```

```
当一个对象被序列化时,只保存对象的非静态成员变量,不能保存任何的成员方法和静态的成员变量

如果一个对象的成员变量是对象,那么这个对象的数据成员也会被保存
```

```
静态变量也不能序列化
transient, 瞬时, 不可序列化, 标记一个引用
```

```
代码 lesson15
```

```
线程
```

```
进程与线程的区别

多个进程的内部数据和状态都是完全独立的,而多线程是共享一块内存空间和一组系统资源,有可能互相影响

线程本身的数据通常只有寄存器数据, 以及一个程序执行时使用的堆栈,所以线程的切换比进程切换的负担要小
```

```
java 中如果我们自己没有产生线程,那么系统就会给我们产生一个线程(主线程,
main方法就是在主线程上执行),我们的程序都是由线程来执行的.
```

```
进程,执行中程序,程序是静态的概念,进程是动态的概念
```

```
一个进程至少包含一个线程
```

```
对于单核CPU来说,某一时刻只能有一个线程在执行(微观串行)
从宏观角度,多个线程同时执行.宏观并行

对双核或双核以上的cpu来说,可以真正做到微观并行.
```

```
当使用第一种方式来生成线程对象时,我们需要重写run方法,因为Thread类的run方法此时什么事情也不做.

当使用第二种方式来生成线程对象时, 我们需要实现Runnable接口的run方法,
然后使用new Thread(new MyThread()) 来生成线程对象,
这时的线程对象的run方法或调用MyThread类的run方法,
这样我们自己编写的run方法就执行了.

两种方法均需执行线程的start方法为线程分配必须的系统资源,
调度线程运行并执行线程的run方法.

在具体应用中采用哪种方法来构造线程体要视具体情况而定.
通常,当一个线程已继承了另一个类,即应该使用第二种方式来构造.即实现runnable接口
```

```
线程的消亡不能通过调用stop命令,而是让run方法自然结束
用一个while循环执行任务,定义一个flag,判断后自然结束
```

```
线程的声明周期:

1. 创建状态
当用new操作符创建一个新的线程对象时,该线程处于创建状态.
处于创建状态的线程只是一个空的线程对象,系统不为他分配资源

2. 可运行状态
执行线程的start方法将为线程分配必须的系统资源.
安排其运行,并调用线程体run方法,这样就使得该线程处于可运行状态runnable
这一状态并不是运行中状态,因为线程也实际并未真正运行

3. 不可运行状态
当发生下列事件时,处于运行状态的线程会转入到不可运行状态

    调用了sleep方法

    线程调用wait方法等待特定条件满足

    线程输入输出阻塞

4. 消亡状态
当线程的run方法执行结束后,该线程自然消亡
```

```
线程的调度策略

如发生以下情况就会终止线程的运行

线程体中调用了yield()方法,让出了对CPU的占用权
sleep()
io阻塞
另一个更高优先级的线程出现
时间片用完
```

```
多线程的同步

为什么要引入同步机制

在多线程环境中, 可能会有两个甚至更多的线程试图同时访问一个有限的资源
必须对这种潜在的资源冲突进行预防

解决方法:
在线程使用一个资源时为其加锁即可.
访问资源的第一个线程为其加上锁以后,其他线程便不能再使用那个资源,除非被解锁
```

```
关于成员变量与局部变量

如果一个变量是成员变量,那么多个线程对同一个对象的成员变量进行操作时,
他们对该成员变量是彼此影响的.也就是说一个线程对成员变量的影响会影响到另一个线程

如果一个变量是局部变量,那么每个线程都会有一个该局部变量的拷贝,
一个线程对该局部变量的改变不会影响到其他线程
```

```
synchronized 关键字, 其修饰的方法叫做同步方法.

Java里面每个对象都有一把锁,这个锁叫monitor(监视器),lock.
当一个方法为同步方法时,当线程访问这个方法,这个线程就会把这个对象(!!)上锁,第二个线程就不能访问.只能等着.

确实是给对象上锁, 比如有一个类定义了两个同步方法.
对象只有一个.
起两个线程,传入该对象,分别执行两个同步方法,
那么这两个方法会顺序执行.
因为第一个线程把对象上锁了.另一个线程给对象上不了锁,不能执行该对象里面的任何同步方法.
```

```
如果某个synchronized方法是static的,那么当线程访问该方法时,
它锁的并不是synchronized方法所在的对象,而是synchronized方法所在的对象所对应的class对象.
因为Java中无论一个类有多少个对象,这些对象会对应唯一一个class对象,
因此当线程分别访问同一个类的两个对象的两个static synchronized方法时,
他们的执行顺序也是顺序的.
也就是说一个线程先去执行方法,执行完毕后另一个线程才开始执行.
```

```
// 定义任意对象都可以
private Object object = new Object();
synchronized(object) {
    System.out.println("hello");
}
同步块,细粒度

// 锁当前对象
synchronized(this) {
    System.out.println("hello");
}

而synchronized方法粗粒度,性能低.
```

```
多线程同步

线程间的相互作用

wait and notify

the pools:

    Wait pool
    Lock pool
```

```
wait 与 notify 方法都是定义在Object类中,而且是final的
因此会被所有的Java类继承并且无法重写.
这两个方法要求在调用时线程应该已经获得了线程的锁,
因此对这两个方法的调用需要放在synchronized方法或块中.

当线程执行了wait方法时,它会释放掉对象的锁,其他对象就能获得对象的锁.

sleep, 暂停线程执行, 不会释放锁.
另一个会导致线程暂停的方法就是Thread类的sleep方法,
它会导致线程睡眠指定的毫秒数,
但线程在睡眠的过程中是不会释放掉对象的锁的.

wait 如果没有被唤醒是永远不会醒来的
sleep 在经过了指定的毫秒之后会自动醒来
```

```
notify 和 notifyAll 使用起来是差不多的.

notifyAll是通过所有线程都醒来,但是谁能抢到锁还不一定.
```

```
深拷贝(deep clone), 浅拷贝(shallow clone)

浅复制, 被复制对象的所有变量都含有与原来对象相同的值,
而所有的对其他对象的引用仍然指向原来的对象.
换言之,浅复制仅仅复制所拷贝的对象, 而不复制它引用的对象.

深复制, 被复制对象的所有变量都含有与原来对象相同的值.
除去那些引用其他对象的变量.
那些引用其他对象的变量将指向被复制过的新对象.
换言之,深复制把要复制的对象所引用的对象都复制了一遍.
```

```
Java的clone方法,定义的Object类中

clone方法将对象复制一份并返回给调用者.
1. 对任何的对象x, 都有x.clone() != x
    克隆对象与原对象不是同一个对象

2. x.clone().getClass() == x.getClass()
    克隆对象与原对象的类型一样

3. 如果对象的equals方法定义恰当,
    x.clone().equals(x)

    Object 的equals方法比较的内存地址.
```