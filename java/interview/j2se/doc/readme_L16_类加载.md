# java SE Lesson 16

```
JVM ClassLoader 类加载器深入剖析
```

```
Java虚拟机与程序的生命周期

在如下几种情况下,Java虚拟机将结束生命周期

执行了System.exit()方法
程序正常执行结束
程序在执行过程中遇到了异常或错误而异常终止
由于操作系统出现错误而导致Java虚拟机进程退出
```

```
类的加载连接与初始化

加载: 查找并加载类的二进制数据

连接:

    验证: 确保被加载的类的正确性
    准备: 为类的静态变量分配内存,并将其初始化为默认值
    解析: 把类中的符号引用转换为直接引用

初始化: 为类的静态变量赋予正确的初始值
```

```
Java 对类的使用可以分为两种

主动使用
被动使用

所有的Java虚拟机实现必须在每个类或接口被Java程序"首次主动使用"时才初始化他们
```

```
主动使用, 6种情况

创建类的实例

访问某个类或接口的静态成员变量, 或者对该静态变量赋值

调用类的静态方法

反射,如,Class.forName("com.shegnsiyuan.Test")

初始化一个类的子类

Java虚拟机启动的时候被表明为启动类的类

除了以上6中情况,其他使用Java类的方式被看作是对类的别动使用,都不会导致类的初始化
```

```
类的加载

类的加载指的是将类的.class文件中的二进制数据读入到内存中,
将其放在运行时数据区的方法区内,
然后在堆区创建一个Java.lang.Class对象,
用来封装类在方法区内的数据结构
```

```
加载.class文件的方式

从本地系统中直接加载
通过网络下载.class文件
从zip,jar等归档文件中加载.class文件
从专有数据库中提取.class文件
将Java源文件动态编译为.class文件

类加载的最终产品是位于堆区中的class对象
Class对象封装了类在方法区内的数据结构,
并且向Java程序员提供了访问方法区内的数据结构的接口,这些接口全都是反射接口
```

```
有两种类型的类加载器

Java虚拟机自带的加载器
    根类加载器 Bootstrap

    扩展类加载器 Extention
    系统类加载器 System, 应用加载器

    ext,sys, 是Java代码
    boot 是C++写的

用户自定义的类加载器

    java.lang.ClassLoader 的子类
    用户可以定制类的加载方式
```

```
每一个类都是由ClassLoader加载的,
每一个类由持有加载它的ClassLoader的引用
```

```
动态代理,实现InvocationHandler,覆写invoke方法
传的第一个参数是一个ClassLoader, 
动态的加载到内存里面,有什么加载,类加载器
由我们指定的类加载器将类加载到内存里面
```

```
类加载器 并不需要 等到某个类被首次使用时再加载它

JVM规范允许类加载器在预料某一类将要被使用时就预先加载它
如果在预先加载的过程中遇到了.class文件缺失或存在错误,
类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)

如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误
```

```
类被加载过后,就进入到连接阶段.
连接就是将已读到内存中的类的二进制数据合并到虚拟机的运行时环境中去
```

```
类的验证内容

类文件的结构检查
语义检查
字节码验证
二进制兼容性验证
```

```
在准备阶段,Java虚拟机为类的静态变量分配内存,并设置默认的初始值.
例如对以下Sample类,在准备阶段
将为int 类型的静态变量a 分配4个字节的内存空间,并且赋予默认值0
位long 类型的静态变量b 分配8个字节的内存空间,并且赋予默认值0

public class Sample {
    private static int a = 1;

    public static long b;

    static {
        b = 2;
    }
    ...
}
```

```
在解析阶段, Java虚拟机会把类的二进制数据中的符号引用,替换为直接引用.

例如,在Worker类的 gotoWorker()方法中会引用 Car类的run()方法.

public void todoWork(){
    car.run(); // 这段代码在 Worker 类的二进制数据中表示为符号引用
}

在 Worker 类的二进制数据中,包含了一个对 Car 类的 run() 方法的符号引用
它由 run() 方法的全名和相关描述符组成.
在解析阶段,Java虚拟机会把这个符号引用替换为一个指针,
该指针指向Car类的run()方法在方法区内的内存位置,这个指针就是直接引用
```

```
当Java虚拟机初始化一个类时, 要求它的所有父类都已经被初始化,但是这条规则并不适用与接口

    在初始化一个类时,并不会先初始化它所实现的接口
    在初始化一个接口时, 并不会先初始化它的父接口

因此,一个父接口并不会因为他的子接口或者实现类的初始化而初始化,
只有当程序首次使用特定接口的静态变量时, 才会导致该接口的初始化.

只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时,
才可以认为是对类或接口的主动使用

调用ClassLoader类的loadClass 方法加载一个类,并不是对类的主动使用,
不会导致类的初始化
```

```
父亲委托机制的优点是能够提高软件系统的安全性.
因为在此机制下,用户自定义的加载器不可能加载应该由父加载器加载的可靠类.
从而防止不可靠甚至恶意的代码代替由父加载器加载的可靠代码.
例如: java.lang.Object 类总是由根加载器加载
其他任意用于自定义的类加载器不可能加载含有恶意代码的 java.lang.Object类
```

```
每个类加载器都有自己的命名空间, 命名空间由该加载器及所有父加载器所加载的类组成.
在同一个命名空间中,不会出现类的完整名字相同的两个类,
在不同命名空间中,有可能会出现类的完整名字相同的两个类.
```

```
要创建用户自己的类加载器,只需要扩展 java.lang.ClassLoader 类,
然后覆盖它的 findClass(String name) 方法即可.
该方法根据参数指定的类的名字,返回对应的Class对象的引用.
```

```
一个类的所有对象都被垃圾回收后,这个类也会被卸载

由Java虚拟机自带的类加载器所加载的类,在虚拟机的声明周期中.始终不会被卸载.
前面已经介绍过, Java虚拟机自带的加载器包括根加载器,扩展类加载器,系统类加载器.
Java虚拟机本身会始终引用这些类加载器,而这些类加载器则会使用引用他们所加载的类的class对象,因此这些class对象始终是可触及的.

!! 由用户自定义的类加载器所加载的类是可以被下载的.
```

```
在类加载器的内部实现中,用一个Java集合来存放所加载的类的引用.

另一方面,一个class对象总是会引用它的类加载器,
调用Class对象的getClassLoader()方法,就能获得他的类加载器.

由此可见,代表Sample类的Class实例与load1之间为双向关联关系.
```