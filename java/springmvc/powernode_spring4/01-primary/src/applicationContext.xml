<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> <!-- bean definitions here -->


    <!--
        实际上可以从逻辑上认为这个文件就是一个容器

        注册Bean: 下面的注册, 相当于在代码中写的
        ISomeService someService = new SomeServiceImpl();

        默认是单例的, 通过scope变量来指定，可以是 prototype, request, session

        prototype: 原型模式, 使用时才由容器创建,每次使用时创建
        singleton: 单例模式(默认)，容器初始化时由容器创建

        id就相当于容器为我们创建的对象的名字，标识。
    -->
    <bean id="someService" class="com.bjpowernode.service.SomeServiceImpl" />

    <!-- init-method="" destroy-method="" 这两个参数对应接口的两个方法, 管理 bean 的生命周期 -->
    <!--
        bean 的生命周期有很多步骤,非常复杂,每个步骤我们都是可以插入代码来进行控制的,了解即可
        一共有 11 个步骤, 每个步骤都可以插入代码
    -->

    <!-- 一样的class, 不一样的id, 容器会创建两个对象 -->
    <bean id="someService_another_object" class="com.bjpowernode.service.SomeServiceImpl" scope="singleton" />

    <!-- Bean的装配 - 动态工厂Bean 例子 -->
    <bean id="someFactory" class="com.bjpowernode.service.SomeFactory" />
    <!-- 在容器中指定用来创建最终对象的工厂，并指定工厂中创建该对象的方法. 就将工厂与最终代码分开 -->
    <!-- 表明someServiceByFactory对象是由someFactory这个工厂Bean的getSomeService()方法创建的 -->
    <bean id="someServiceByFactory" factory-bean="someFactory" factory-method="getSomeService" />

    <!-- 静态工厂 -->
    <bean id="someServiceByFactoryStatic" class="com.bjpowernode.service.SomeFactory" factory-method="getSomeServiceStatic" />


    <!-- 注册 bean 后处理器 容器初始化, bean 实例化 时 执行 -->
    <!-- 是继承的BeanPostProcessor,会被自动调用 -->
    <bean class="com.bjpowernode.service.MyBeanPostProcessor" />

    <!-- 设值注入 -->
    <bean id="mySchool" class="com.bjpowernode.service.School">
        <property name="name" value="科成" />
    </bean>
    <bean id="student" class="com.bjpowernode.service.Student">
        <!-- 会调用Student类的 set() 方法 -->
        <property name="name" value="libobo" />
        <property name="age" value="22" />
        <property name="school" ref="mySchool" />
    </bean>

    <!-- 构造注入 -->
    <!-- 设值注入用得最多，构造注入基本不用 -->
    <bean id="teacher" class="com.bjpowernode.service.Teacher">
        <constructor-arg name="name" value="teacher li"/>
    </bean>

    <!-- 除了扫描指定的包，还会扫描子包 -->
    <!-- com.bjpowernode.* 这种写法，只扫描子包，不扫描当前包:com.bjpowernode -->
    <!-- com.bjpowernode 这种写法，先扫描当前包，没有再扫描子包 -->
    <context:component-scan base-package="com.bjpowernode" />

    <!-- 目标对象 -->
    <bean id="handService" class="com.bjpowernode.handaop.HandServiceImpl" />
    <!-- 通知：前置通知 -->
    <bean id="beforeAdvice" class="com.bjpowernode.handaop.MyMethodBeforeAdvice" />

    <!--切面： 名称匹配方法切入点顾问-->
    <bean id="beforeAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
        <property name="advice" ref="beforeAdvice" />
        <!-- 指定方法名 -->
        <property name="mappedNames" value="doLeft,doRight" />
        <!--
        <property name="mappedName" value="doLeft" />
        <property name="mappedNames">
            <array>
                <value>doLeft</value>
                <value>doRight</value>
            </array>
        </property>
        -->
    </bean>

    <!--切面： 正则表达式方法切入点顾问-->
    <bean id="regAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
        <property name="advice" ref="beforeAdvice" />
        <!-- 正则表达式匹配的对象是： 权限定方法名,而不仅仅是简单方法名(包含完整的包名) -->
        <property name="pattern" value=".*S.*" />
    </bean>


    <!-- 代理对象的生成，注意这里的 ProxyFactoryBean不是代理类，而是代理对象生成器 -->
    <!-- 代理工厂bean有两个问题，1.每次只能代理一个，导致这里需要配置多个，代码冗余 -->
    <!-- 用自动代理生成器解决 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="handService" />
        <property name="interceptorNames" value="beforeAdvice" />
        <!--<property name="interfaces" value="com.bjpowernode.handaop.IHandService" />-->
        <!--<property name="targetName" value="handService" />-->
    </bean>

    <!-- 自动代理生成器, 底层是bean后处理器 -->
    <!-- 只处理advisor, 不处理advice，只能是切面，没办法挑选目标对象 -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" />

    <!-- Bean名称 自动代理生成器, 不仅能指定目标对象，还能指定切面，并且切面可以是顾问和通知 -->
    <bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
        <property name="beanNames" value="someService1" />
        <property name="interceptorNames" value="beforeAdvisor" />
    </bean>

</beans>