### 说说API的防重放机制



在很多时候前段调用我们后台接口的时候如果前端忘记加去重复点击的话，如果网络有延迟，或者使用者故意连续点击。而且后台没对接口做防重处理的话，这时候数据库就会产生两条记录了。比如注册用户的时候，如果接口没做这个处理，用户连续点击了。那就相当于新增了两个一模一样的记录那这肯定不是我们大程序不想看到的事情。好了，废话不多说让我们来看看如何做到后台接口防重呢。

解决：
首先自己也是在网上看了很多关于这块的文章，不过思路大概都差不多。
一.用令牌的方式给接口接口做认证

> - 1.每次调用接口前后台生成一个随机唯一的token给前端，并且后台将此token存在session中。
> - 2.前端调用接口时，将该token放入header中传递到后台。
> - 3.后台收到前端的请求时将该请求进行拦截，获取该请求的token跟服务器的token进行对比。
> - 4.如果相等则放行，且将session中的token移除，如果不相等则，拦截该接口，并将错误反馈给前段

以上是用session做处理的整体思路，那么接下来我们来用代码展示吧

自定义注解

```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FormToken {

    /**
     * 是否在页面生成TOKEN
     *
     * @return
     */
    boolean produce() default false;

    /**
     * 是否删除旧 TOKEN
     *
     * @return
     */
    boolean remove() default false;
}
```

自定义拦截器（基于spring boot）

```
    public class FormTokenInterceptor extends HandlerInterceptorAdapter {
    public final static String TOKEN_NAME = "resubmitToken";


    /**
     * 方法处理前处理
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        FormToken formToken = method.getAnnotation(FormToken.class);
        if (null != formToken) {
            if ((formToken.produce() && formToken.remove()) || (!formToken.produce() && !formToken.remove())) {
                throw new RuntimeException("请不要在同一个方法上同时注解：@FormToken(remove = true/false, produce = true/false)");
            } else if (formToken.produce()) {
                request.getSession().setAttribute(TOKEN_NAME, TokenUtils.getToken());
            } else if (formToken.remove()) {
                String serverToken = (String) request.getSession().getAttribute(TOKEN_NAME);
                String clientToken = request.getParameter(TOKEN_NAME);
                request.getSession().removeAttribute(TOKEN_NAME); // remove token
                if (serverToken==null||clientToken==null||!StringUtils.equals(serverToken, clientToken)) {
//                    if (null != method.getAnnotation(ResponseBody.class)) { // JSON
                        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
                        PrintWriter out = response.getWriter();
                        out.print(new ObjectMapper().writeValueAsString(new GanjieResponse<>("500","无效请求，请刷新页面后重试")));
                        out.flush();
                        out.close();
//                    } else { // 普通页面
//                        request.getRequestDispatcher("/error/invalidRequest").forward(request, response);
//                    }
                    return false;
                }
            }
        }
        return super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

    }

}
```

配置拦截器拦截

```
@ControllerAdvice
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new FormTokenInterceptor()).addPathPatterns("/**");
        super.addInterceptors(registry);
    }
}
```

接口中使用

```
/**
 * test 接口
 * 测试生成提交令牌
 * @param bizId 业务主键
 * @return
 */
@Permission
@ResponseBody
@RequestMapping(value = "/apply/test/getResubmitToken.do", method = {RequestMethod.POST})
@FormToken(produce = true)
public GanjieResponse<Map<String,Object>> getResubmitToken(HttpServletRequest request, String bizId) {
    String resubmitToken = request.getSession().getAttribute("resubmitToken").toString();
    Map<String,Object> map = new HashMap<>();
    map.put("resubmitToken",resubmitToken);
    GanjieResponse<Map<String,Object>> result = new GanjieResponse<>(GanjieResponse.SUCCESS,"生成成功", map);
    return result;
}

/**
 * test 接口
 * 测试防止重复提交
 * @param bizId 业务主键
 * @return
 */
@Permission
@ResponseBody
@RequestMapping(value = "/apply/test/checkResubmitToken.do", method = {RequestMethod.POST})
@FormToken(remove = true)
public GanjieResponse<Boolean> checkResubmitToken(HttpServletRequest request, String bizId) {
    GanjieResponse<Boolean> result = new GanjieResponse<>(GanjieResponse.SUCCESS,"检查成功", true);
    return result;
}
```

到此为止通过session防止接口重复调用的代码就是这些了。但是到了这可能大家会问，如果只是单应用且只有一台服务器的时候确实是可以满足了，但是如果有多台服务器的时候就不行了。因为session是存在服务器的。如果多台服务器设置了负载均衡，也就是说随机访问到某一台服务器，所以我们就不能够保证每次判断都是正确的了。当然也可以配置固定访问一台服务器，但是这终究不是最好的解决办法。最好的办法是我们能够有一台独立的服务器用来存储session。如果没有也没关系了。我们可以用redis呀。
用redis跟上面的思路是一样的，如过要生成，保存token的时候有点不一样而已步骤如下：

> - 1.生成token，用sessionId作为key（保证一个用户只有一条记录），token为value。但是保存的时候先检查是否存在记录，如果存在则将value更新即可，不存在则新增
> - 2.判断时根据sessionId取的value 比较。如果校验通过后将该记录从redis中remove即可

问题到这基本都能解决了。刚好看到一篇关于API防重机制的文章，感觉不错也顺便贴出来

# 说说API的防重放机制

我们在设计接口的时候，最怕一个接口被用户截取用于重放攻击。重放攻击是什么呢？就是把你的请求原封不动地再发送一次，两次...n次，一般正常的请求都会通过验证进入到正常逻辑中，如果这个正常逻辑是插入数据库操作，那么一旦插入数据库的语句写的不好，就有可能出现多条重复的数据。一旦是比较慢的查询操作，就可能导致数据库堵住等情况。

这里就有一种防重放的机制来做请求验证。

# timestamp+nonce

我们常用的防止重放的机制是使用timestamp和nonce来做的重放机制。

timestamp用来表示请求的当前时间戳，这个时间戳当然要和服务器时间戳进行校正过的。我们预期正常请求带的timestamp参数会是不同的（预期是正常的人每秒至多只会做一个操作）。每个请求带的时间戳不能和当前时间超过一定规定的时间。比如60s。这样，这个请求即使被截取了，你也只能在60s内进行重放攻击。过期失效。

但是这样也是不够的，还有给攻击者60s的时间。所以我们就需要使用一个nonce，随机数。

nonce是由客户端根据足够随机的情况生成的，比如 md5(timestamp+rand(0, 1000)); 它就有一个要求，正常情况下，在短时间内（比如60s）连续生成两个相同nonce的情况几乎为0。

## 服务端

服务端第一次在接收到这个nonce的时候做下面行为：
1 去redis中查找是否有key为nonce:{nonce}的string
2 如果没有，则创建这个key，把这个key失效的时间和验证timestamp失效的时间一致，比如是60s。
3 如果有，说明这个key在60s内已经被使用了，那么这个请求就可以判断为重放请求。

## 示例

那么比如，下面这个请求：

[http://a.com?uid=123&timestamp=1480556543&nonce=43f34f33&sign=80b886d71449cb33355d017893720666](http://a.com/?uid=123&timestamp=1480556543&nonce=43f34f33&sign=80b886d71449cb33355d017893720666)

这个请求中国的uid是我们真正需要传递的有意义的参数

timestamp，nonce，sign都是为了签名和防重放使用。

timestamp是发送接口的时间，nonce是随机串，sign是对uid，timestamp,nonce(对于一些rest风格的api，我建议也把url放入sign签名)。签名的方法可以是md5({秘要}key1=val1&key2=val2&key3=val3...)

服务端接到这个请求：
1 先验证sign签名是否合理，证明请求参数没有被中途篡改
2 再验证timestamp是否过期，证明请求是在最近60s被发出的
3 最后验证nonce是否已经有了，证明这个请求不是60s内的重放请求