Python Interview IO

  写服务器处理模型的程序时，通常有以下几种模型：
  1.每收到一个请求，创建一个新的进程来处理该请求
  2.每收到一个请求，创建一个新的线程来处理该请求
  3.每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求（协程）
  这三种模型的区别：
  第1种模型：由于创建新的进程的开销比较大，会导致服务器性能比较差，但实现比较简单
  第2种模型：由于要涉及到线程的同步，有可能面临死锁
  第3种模型：在写应用程序代码时，逻辑比前2种要复杂。但这种模型是大多数网络服务器采用的方式

  协程的标准定义，即符合以下所有条件就能称之为协程：
  1.在单线程里实现并发
  2.修改共享数据不需要加锁
  3.用户程序里自己保存多个控制流的上下文栈
  4.一个协程遇到IO操作自动切换到其它协程

  协程的好处：
  无需线程上下文切换的开销
  无需原子操作锁定及同步的开销
    原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束
  方便切换控制流，简化编程模型
  高并发+高扩展性+低成本：一个CPU支持上万的协程都行，很适合用于高并发处理
  协程的缺点：
  无法利用多核资源：
    协程的本质是个单线程，它不能同时将单个CPU的多个核用上
    协程需要和进程配合才能运行在多CPU上。
  进行阻塞（Blocking）操作（如IO）时会阻塞掉整个程序

如何在单线程下实现并发效果？
  答案是遇到IO操作就切换，因为IO操作耗时比较长
  协程之所以能处理高并发，其实就是把IO操作给干掉了，就是一遇到IO操作就切换。
  这样的话整个程序就变成了只有CPU在运算。
  一遇到IO操作就切换，那么到底什么时候再切回去呢？
  答案是当IO操作结束后就切回去。
  那么问题又来了，python怎么来监测IO操作是否结束呢？带着这个问题先来看看几个例子
 现在我们可以来回答下这个问题了，python如何监测IO操作是否结束？
  IO操作是由操作系统进行处理的，当遇到IO操作时就切换
  等IO操作完以后让其调用回调函数，回调函数会通知协程说这个IO操作完成了

# Linux 启动过程
【BIOS(MBR)】开机自检，通过通过BIOS加载CMOS，获取各种硬件信息。
【GRUB】通过引导器（GNU/Linux 引导器包括 GRUB 和 Syslinux）读取分区表。
【载入内核】操作系统接管硬件以后，首先将系统内核载入RAM，执行内核代码设置自己的虚拟内存子系统和根文件系统,对硬件进行检测并进行设备驱动程序初始化。
【初始化】执行/sbin/init 生成第一个进程，接管系统控制权，它首先会去读取/etc/inittab文件来执行相应的脚本进行系统初始化，如设置键盘、字体，装载模块，设置网络等。
【用户登录】
【桌面载入】

【select】
每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大。
同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。
select支持的文件描述符数量太小了，默认是1024。

【poll】
poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd数组而不是select的fd_set结构，所以poll克服了select文件描述符数量的限制。

【epoll】

【Reactor】
http://xymlife.com/2016/01/16/Reactor/
Reactor设计模式在高性能I/O框架中随处可见，例如redis，tornado，gevent，libevent等。
Reactor可以翻译为反应器，是一种基于事件驱动的设计模式。
总结：在Reactor模式中，处理事件的程序不会去调用反应器，而是告诉Reactor监听一个事件，和这个事件发生时处理方法，当Reactor监测到这个事件发生时，就启动对应的处理方法（一般是回调函数）进行处理，这种控制逆转又称为“好莱坞法则”（不要调用我，让我来调用你）。
最后总结一下Reactor的优点：
1. 响应快：不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的。
2. 编程相对简单： 可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销。
3. 可扩展性： 可以方便的通过增加Reactor实例个数来充分利用CPU资源。
4. 可复用性： reactor框架本身与具体事件处理逻辑无关，具有很高的复用性。

 三次握手的目的是为了确认客户端与服务端都能接收到对方的信息，以下是三次握手的详细过程：
    第一次握手：客户端给服务端发送请求包
      此时服务端确认自己可以接收到客户端的请求包
      客户端无法确认服务端是否接收到了自己发的请求包
    第二次握手：服务端回复客户端
      此时客户端确认自己发的请求包已被服务端收到，也确认自己可以正常接收服务端发来的包
      服务端可以确认自己能接收到客户端的包，但不能确认客户端是否能收到自己发送的包
    第三次握手：客户端回复服务端
      此时客户端已无疑问
      服务端也确认刚刚客户端收到了自己的回复包。两边都没问题了，开始通信
  在python中提供了两个socket编程模块，分别是socket和socketserver。
  我们先来说说socket编程需要经历哪些步骤：
   客户端：
      1、创建socket客户端连接对象
      2、通过连接对象的connect()方法连接服务端
      3、通过连接对象的send()方法给服务端发送信息或指令
      4、通过连接对象的recv()方法接收服务端的返回信息
      5、通过连接对象的close()方法断开连接
   服务端：
      1、创建socket服务端连接对象
      2、通过连接对象的bind()方法绑定要监听的IP与端口
      3、通过连接对象的listen()方法来监听
      4、通过连接对象的accept()方法创建与客户端交互的子连接对象并等待客户端连接
      5、接收并处理客户端的请求
      6、将处理结果返回给客户端

